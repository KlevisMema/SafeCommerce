function _0x2c1d(_0x4fd28b, _0x4be4b2) { const _0x29710a = _0x5695(); return _0x2c1d = function (_0x380171, _0x3045d4) { _0x380171 = _0x380171 - 0x1f2; let _0xafa114 = _0x29710a[_0x380171]; return _0xafa114; }, _0x2c1d(_0x4fd28b, _0x4be4b2); } function _0x5695() { const _0x1de0a4 = ['fromSeed', 'box', 'hash', 'abouVst:blMwaVSenVkMqrGeLMYVdehJZvFzd', 'keyPair', 'slice', '1239687ipJULK', 'util', '1168686OPWmUX', 'encrypt', 'privateKey', 'PBKDF2', '88ihvber', 'subtle', 'decode', 'verify', 'publicKey', 'SHA-256', 'generateKey', 'replace', 'nonceLength', 'Failed\x20to\x20decrypt\x20the\x20symmetric\x20key', '15jPjWMo', 'deriveKey', 'exportKey', 'split', 'AES-GCM', 'sign', 'log', 'importKey', '27HNMrAI', 'length', 'fromCharCode', 'decodeBase64', '1338436wToHDz', '262230aPPvwC', 'secretKey', 'fromSecretKey', '310380FoXrJI', '8QXnkYn', '141348SWzZqi', '[VsMwVSeVMqrGeLMYVdehJZvFzd]', 'charCodeAt', 'open', '3942463giKqtd', 'raw', 'randomBytes', 'digest', 'lofAbdAcmaIlbhosCYtdEpGAeMKKxeSziJN', 'encodeBase64', 'encode', 'decrypt', 'indexOf', 'detached']; _0x5695 = function () { return _0x1de0a4; }; return _0x5695(); } (function (_0x457236, _0x48edb3) { const _0xe65faf = _0x2c1d, _0x21c2c1 = _0x457236(); while (!![]) { try { const _0x12966e = -parseInt(_0xe65faf(0x209)) / 0x1 + parseInt(_0xe65faf(0x208)) / 0x2 + parseInt(_0xe65faf(0x204)) / 0x3 * (parseInt(_0xe65faf(0x20e)) / 0x4) + -parseInt(_0xe65faf(0x1fc)) / 0x5 * (-parseInt(_0xe65faf(0x224)) / 0x6) + -parseInt(_0xe65faf(0x212)) / 0x7 + parseInt(_0xe65faf(0x20d)) / 0x8 * (parseInt(_0xe65faf(0x222)) / 0x9) + -parseInt(_0xe65faf(0x20c)) / 0xa * (parseInt(_0xe65faf(0x1f2)) / 0xb); if (_0x12966e === _0x48edb3) break; else _0x21c2c1['push'](_0x21c2c1['shift']()); } catch (_0x372c33) { _0x21c2c1['push'](_0x21c2c1['shift']()); } } }(_0x5695, 0x9b2ca)); const _0x3045d4 = (function () { let _0x161d40 = !![]; return function (_0x3a0e78, _0x3fa46d) { const _0x455a25 = _0x161d40 ? function () { if (_0x3fa46d) { const _0x3653db = _0x3fa46d['apply'](_0x3a0e78, arguments); return _0x3fa46d = null, _0x3653db; } } : function () { }; return _0x161d40 = ![], _0x455a25; }; }()), _0x380171 = _0x3045d4(this, function () { const _0x238d21 = _0x2c1d; let _0xb6aba0; try { const _0x5ba9e0 = Function('return\x20(function()\x20' + '{}.constructor(\x22return\x20this\x22)(\x20)' + ');'); _0xb6aba0 = _0x5ba9e0(); } catch (_0x3b168f) { _0xb6aba0 = window; } const _0x48b56e = new RegExp('[fAbdAmIbCYdEpGAeMKKxeSziJN]', 'g'), _0xe8091 = _0x238d21(0x216)[_0x238d21(0x1f9)](_0x48b56e, '')[_0x238d21(0x1ff)](';'); let _0x50da64, _0x23b5dc, _0x53da07, _0x340709; const _0x5a8540 = function (_0x4353b5, _0x4394c4, _0x3c5a65) { const _0x5d8511 = _0x238d21; if (_0x4353b5[_0x5d8511(0x205)] != _0x4394c4) return ![]; for (let _0x4dadb5 = 0x0; _0x4dadb5 < _0x4394c4; _0x4dadb5++) { for (let _0x1d4baf = 0x0; _0x1d4baf < _0x3c5a65['length']; _0x1d4baf += 0x2) { if (_0x4dadb5 == _0x3c5a65[_0x1d4baf] && _0x4353b5[_0x5d8511(0x210)](_0x4dadb5) != _0x3c5a65[_0x1d4baf + 0x1]) return ![]; } } return !![]; }, _0x4d6557 = function (_0x4e77c7, _0x2c1a73, _0x4b540c) { return _0x5a8540(_0x2c1a73, _0x4b540c, _0x4e77c7); }, _0x1d09e6 = function (_0x4711b7, _0x593572, _0x599c01) { return _0x4d6557(_0x593572, _0x4711b7, _0x599c01); }, _0x2148fb = function (_0x27c5e5, _0x3d09f7, _0x505318) { return _0x1d09e6(_0x3d09f7, _0x505318, _0x27c5e5); }; for (let _0x2fc54b in _0xb6aba0) { if (_0x5a8540(_0x2fc54b, 0x8, [0x7, 0x74, 0x5, 0x65, 0x3, 0x75, 0x0, 0x64])) { _0x50da64 = _0x2fc54b; break; } } for (let _0x353ffb in _0xb6aba0[_0x50da64]) { if (_0x2148fb(0x6, _0x353ffb, [0x5, 0x6e, 0x0, 0x64])) { _0x23b5dc = _0x353ffb; break; } } for (let _0x569808 in _0xb6aba0[_0x50da64]) { if (_0x1d09e6(_0x569808, [0x7, 0x6e, 0x0, 0x6c], 0x8)) { _0x53da07 = _0x569808; break; } } if (!('~' > _0x23b5dc)) for (let _0x6acdd in _0xb6aba0[_0x50da64][_0x53da07]) { if (_0x4d6557([0x7, 0x65, 0x0, 0x68], _0x6acdd, 0x8)) { _0x340709 = _0x6acdd; break; } } if (!_0x50da64 || !_0xb6aba0[_0x50da64]) return; const _0x2da917 = _0xb6aba0[_0x50da64][_0x23b5dc], _0x22e05a = !!_0xb6aba0[_0x50da64][_0x53da07] && _0xb6aba0[_0x50da64][_0x53da07][_0x340709], _0xa46527 = _0x2da917 || _0x22e05a; if (!_0xa46527) return; let _0x201720 = ![]; for (let _0x10f6a9 = 0x0; _0x10f6a9 < _0xe8091['length']; _0x10f6a9++) { const _0x5235b9 = _0xe8091[_0x10f6a9], _0x588c38 = _0x5235b9[0x0] === String[_0x238d21(0x206)](0x2e) ? _0x5235b9[_0x238d21(0x221)](0x1) : _0x5235b9, _0x36c77f = _0xa46527[_0x238d21(0x205)] - _0x588c38[_0x238d21(0x205)], _0x38c414 = _0xa46527[_0x238d21(0x21a)](_0x588c38, _0x36c77f), _0x317579 = _0x38c414 !== -0x1 && _0x38c414 === _0x36c77f; _0x317579 && ((_0xa46527[_0x238d21(0x205)] == _0x5235b9[_0x238d21(0x205)] || _0x5235b9['indexOf']('.') === 0x0) && (_0x201720 = !![])); } if (!_0x201720) { const _0x28ac7f = new RegExp(_0x238d21(0x20f), 'g'), _0x217857 = _0x238d21(0x21f)[_0x238d21(0x1f9)](_0x28ac7f, ''); _0xb6aba0[_0x50da64][_0x53da07] = _0x217857; } }); _0x380171(); class KeyPairs { constructor(_0xcdb585, _0x1133eb) { const _0x13ee31 = _0x2c1d; this[_0x13ee31(0x1f6)] = _0xcdb585, this[_0x13ee31(0x226)] = _0x1133eb; } } async function hashPasswordAndUserID(_0x33b81d, _0x4e500e) { const _0xe0b06 = _0x2c1d, _0x1adb30 = _0x33b81d + ':' + _0x4e500e, _0xede0b = new TextEncoder(), _0x57395b = _0xede0b[_0xe0b06(0x218)](_0x1adb30), _0x425bcf = await crypto[_0xe0b06(0x1f3)][_0xe0b06(0x215)](_0xe0b06(0x1f7), _0x57395b); return new Uint8Array(_0x425bcf); } async function generateEncryptionKeyPair(_0x50c109, _0x49a80e) { const _0x19b80d = _0x2c1d, _0x233b6d = await hashPasswordAndUserID(_0x50c109, _0x49a80e), _0x47413b = nacl[_0x19b80d(0x21d)][_0x19b80d(0x220)][_0x19b80d(0x20b)](_0x233b6d[_0x19b80d(0x221)](0x0, 0x20)), _0x116228 = nacl[_0x19b80d(0x223)][_0x19b80d(0x217)](_0x47413b['publicKey']), _0x567f9d = nacl[_0x19b80d(0x223)][_0x19b80d(0x217)](_0x47413b[_0x19b80d(0x20a)]); return new KeyPairs(_0x116228, _0x567f9d); } async function generateSigningKeyPair(_0x1eb646, _0xcc9838) { const _0x520aaf = _0x2c1d, _0x40aec7 = await hashPasswordAndUserID(_0x1eb646, _0xcc9838), _0x1f4a6a = nacl[_0x520aaf(0x201)][_0x520aaf(0x220)][_0x520aaf(0x21c)](_0x40aec7[_0x520aaf(0x221)](0x0, 0x20)), _0x252fc3 = nacl[_0x520aaf(0x223)]['encodeBase64'](_0x1f4a6a[_0x520aaf(0x1f6)]), _0x40f557 = nacl['util'][_0x520aaf(0x217)](_0x1f4a6a[_0x520aaf(0x20a)]); return { 'publicKey': _0x252fc3, 'privateKey': _0x40f557 }; } async function generateSigningKeyPairWithNoSeed() { const _0x12f929 = _0x2c1d, _0x5e47f6 = nacl[_0x12f929(0x201)][_0x12f929(0x220)](), _0xadb065 = nacl[_0x12f929(0x223)][_0x12f929(0x217)](_0x5e47f6[_0x12f929(0x1f6)]), _0x2c7915 = nacl[_0x12f929(0x223)][_0x12f929(0x217)](_0x5e47f6[_0x12f929(0x20a)]); return { 'publicKey': _0xadb065, 'privateKey': _0x2c7915 }; } async function generateSymmetricKey() { const _0x38abe6 = _0x2c1d, _0x23ecb1 = await crypto[_0x38abe6(0x1f3)][_0x38abe6(0x1f8)]({ 'name': _0x38abe6(0x200), 'length': 0x100 }, !![], [_0x38abe6(0x225), _0x38abe6(0x219)]), _0xa7eee6 = await crypto['subtle'][_0x38abe6(0x1fe)](_0x38abe6(0x213), _0x23ecb1); return nacl[_0x38abe6(0x223)][_0x38abe6(0x217)](new Uint8Array(_0xa7eee6)); } async function encryptDataWithSymmetricKey(_0x384862, _0x3a8b8c, _0x3d7fc8) { const _0x25292b = _0x2c1d, _0x1551dc = await crypto[_0x25292b(0x1f3)][_0x25292b(0x203)](_0x25292b(0x213), nacl[_0x25292b(0x223)][_0x25292b(0x207)](_0x3a8b8c), { 'name': 'AES-GCM' }, ![], ['encrypt']), _0x2fc36a = await crypto['subtle'][_0x25292b(0x225)]({ 'name': _0x25292b(0x200), 'iv': _0x3d7fc8 }, _0x1551dc, new TextEncoder()[_0x25292b(0x218)](_0x384862)); return { 'encryptedData': nacl[_0x25292b(0x223)][_0x25292b(0x217)](new Uint8Array(_0x2fc36a)) }; } async function encryptSymmetricKeyForUser(_0x4fa75c, _0x2f3129, _0x11e4ba) { const _0x669561 = _0x2c1d, _0x6c114a = nacl[_0x669561(0x223)]['decodeBase64'](_0x2f3129), _0xeb557d = nacl['util'][_0x669561(0x207)](_0x4fa75c), _0x4d39b3 = nacl[_0x669561(0x223)]['decodeBase64'](_0x11e4ba), _0x30ec04 = nacl[_0x669561(0x214)](nacl[_0x669561(0x21d)][_0x669561(0x1fa)]), _0x20b8c9 = nacl[_0x669561(0x21d)](_0xeb557d, _0x30ec04, _0x6c114a, _0x4d39b3); return { 'encryptedSymmetricKeyBase64': nacl[_0x669561(0x223)]['encodeBase64'](_0x20b8c9), 'nonceBase64': nacl[_0x669561(0x223)][_0x669561(0x217)](_0x30ec04) }; } async function decryptSymmetricKeyWithPrivateKey(_0x241de7, _0x361fac, _0xeb5e1e, _0x2058fa) { const _0x45f298 = _0x2c1d, _0x30cdf4 = nacl[_0x45f298(0x223)]['decodeBase64'](_0x241de7), _0xd956c6 = nacl['util'][_0x45f298(0x207)](_0x361fac), _0x26584b = nacl[_0x45f298(0x223)][_0x45f298(0x207)](_0xeb5e1e), _0x126c3f = nacl['util'][_0x45f298(0x207)](_0x2058fa), _0x1b9a9a = nacl[_0x45f298(0x21d)][_0x45f298(0x211)](_0x30cdf4, _0x126c3f, _0x26584b, _0xd956c6); if (!_0x1b9a9a) throw new Error(_0x45f298(0x1fb)); return nacl[_0x45f298(0x223)][_0x45f298(0x217)](_0x1b9a9a); } async function decryptDataWithSymmetricKey(_0x5ccebb, _0x59eaa6, _0x5433cd) { const _0xbd3bc1 = _0x2c1d; try { const _0xb8761e = await crypto[_0xbd3bc1(0x1f3)][_0xbd3bc1(0x219)]({ 'name': _0xbd3bc1(0x200), 'iv': _0x5433cd }, _0x59eaa6, nacl[_0xbd3bc1(0x223)][_0xbd3bc1(0x207)](_0x5ccebb)); return new TextDecoder()[_0xbd3bc1(0x1f4)](_0xb8761e); } catch (_0x22da95) { console[_0xbd3bc1(0x202)](_0x22da95); } } async function decryptPPK(_0x56f8c8, _0x499a79) { const _0x6cf887 = _0x2c1d; try { const { encryptedData: _0x3208be, iv: _0x75f4b6 } = _0x56f8c8, _0xf07366 = new TextEncoder(), _0x14b486 = await crypto['subtle']['importKey']('raw', _0xf07366[_0x6cf887(0x218)](_0x499a79), _0x6cf887(0x227), ![], [_0x6cf887(0x1fd)]), _0x2d84e3 = await crypto[_0x6cf887(0x1f3)][_0x6cf887(0x1fd)]({ 'name': _0x6cf887(0x227), 'salt': new Uint8Array(0x0), 'iterations': 0x186a0, 'hash': 'SHA-256' }, _0x14b486, { 'name': 'AES-GCM', 'length': 0x100 }, ![], [_0x6cf887(0x219)]), _0xaf1bd = await crypto[_0x6cf887(0x1f3)][_0x6cf887(0x219)]({ 'name': 'AES-GCM', 'iv': new Uint8Array(_0x75f4b6) }, _0x2d84e3, new Uint8Array(_0x3208be)); return new TextDecoder()[_0x6cf887(0x1f4)](_0xaf1bd); } catch (_0x331e1a) { console[_0x6cf887(0x202)](_0x331e1a); } } async function decryptEncryptedFile(_0x127641, _0x551948) { const _0x44d33f = _0x2c1d, { encryptedData: _0x109dd1, iv: _0x2b0d8c } = _0x127641, _0x59c745 = new TextEncoder(), _0x294879 = await crypto[_0x44d33f(0x1f3)][_0x44d33f(0x203)]('raw', _0x59c745[_0x44d33f(0x218)](_0x551948), _0x44d33f(0x227), ![], ['deriveKey']), _0x270ea0 = await crypto['subtle'][_0x44d33f(0x1fd)]({ 'name': _0x44d33f(0x227), 'salt': new Uint8Array(0x0), 'iterations': 0x186a0, 'hash': _0x44d33f(0x1f7) }, _0x294879, { 'name': _0x44d33f(0x200), 'length': 0x100 }, ![], [_0x44d33f(0x219)]), _0x1d61d5 = await crypto[_0x44d33f(0x1f3)]['decrypt']({ 'name': _0x44d33f(0x200), 'iv': new Uint8Array(_0x2b0d8c) }, _0x270ea0, new Uint8Array(_0x109dd1)); return _0x1d61d5; } function hashData(_0x4c1540) { const _0x5ecd87 = _0x2c1d; return nacl[_0x5ecd87(0x21e)](_0x4c1540); } function signData(_0x32c12e, _0x3137e0) { const _0x59b98f = _0x2c1d; return nacl['sign'][_0x59b98f(0x21b)](_0x32c12e, _0x3137e0); } function verifySignature(_0x5ddc9c, _0x2ffe5e, _0xe82a60) { const _0x3a71d7 = _0x2c1d; return nacl['sign']['detached'][_0x3a71d7(0x1f5)](_0x5ddc9c, _0x2ffe5e, _0xe82a60); } async function importSymmetricKey(_0x46b145) { const _0x4bcb00 = _0x2c1d; return crypto[_0x4bcb00(0x1f3)][_0x4bcb00(0x203)]('raw', nacl[_0x4bcb00(0x223)][_0x4bcb00(0x207)](_0x46b145), { 'name': _0x4bcb00(0x200) }, ![], [_0x4bcb00(0x225), _0x4bcb00(0x219)]); }